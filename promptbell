#!/usr/bin/env sh
set -eu

APP_NAME="promptbell"

STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/promptbell"
SOUND_FILE="$STATE_DIR/sound"
NOTIFY_MODE_FILE="$STATE_DIR/notify"

COOLDOWN=3
IDLE_THRESHOLD_MS=500

mkdir -p "$STATE_DIR"

# ---------------------------
# State helpers
# ---------------------------

current_sound() {
  [ -f "$SOUND_FILE" ] && cat "$SOUND_FILE" || echo "default"
}

notify_mode() {
  [ -f "$NOTIFY_MODE_FILE" ] && cat "$NOTIFY_MODE_FILE" || echo "background"
}

now_ms() {
  date +%s%3N 2>/dev/null || echo $(( $(date +%s) * 1000 ))
}

# ---------------------------
# Focus detection (best effort)
# ---------------------------

is_terminal_focused() {
  case "$(uname)" in
    Darwin)
      osascript -e '
        tell application "System Events"
          set frontApp to name of first application process whose frontmost is true
          frontApp contains "Terminal" or frontApp contains "iTerm"
        end tell
      ' 2>/dev/null | grep -q true
      ;;
    *)
      return 1
      ;;
  esac
}

should_notify() {
  [ "$(notify_mode)" = "always" ] && return 0
  is_terminal_focused && return 1
  return 0
}

# ---------------------------
# Sound & notification
# ---------------------------

play_sound() {
  case "$(current_sound)" in
    none) return ;;
    default)
      command -v afplay >/dev/null && afplay /System/Library/Sounds/Glass.aiff &
      command -v paplay >/dev/null && paplay /usr/share/sounds/freedesktop/stereo/complete.oga &
      ;;
    glass) afplay /System/Library/Sounds/Glass.aiff & ;;
    ping)  afplay /System/Library/Sounds/Ping.aiff & ;;
    pop)   afplay /System/Library/Sounds/Pop.aiff & ;;
    bell)  paplay /usr/share/sounds/freedesktop/stereo/bell.oga & ;;
  esac
}

send_notification() {
  command -v osascript >/dev/null && \
    osascript -e 'display notification "User attention needed" with title "promptbell"' &
  command -v notify-send >/dev/null && notify-send "promptbell" "User attention needed" &
}

# ---------------------------
# Menu-based trigger detection (grouped)
# ---------------------------

LAST_ALERT=0
LAST_OUTPUT_MS=0
PENDING_TRIGGER=0

MENU_STREAK=0
LAST_MENU_LINE_MS=0
MENU_MAX_GAP_MS=200

is_menu_line() {
  # Matches:
  # 1. Option
  # 2) Option
  # [3] Option
  echo "$1" | grep -Eq '^\s*(\[[0-9]+\]|[0-9]+[.)])\s+'
}

try_notify_if_idle() {
  [ "$PENDING_TRIGGER" -eq 1 ] || return

  now="$(now_ms)"
  idle_ms=$(( now - LAST_OUTPUT_MS ))

  if [ "$idle_ms" -ge "$IDLE_THRESHOLD_MS" ]; then
    should_notify || { PENDING_TRIGGER=0; return; }

    if [ $((now - LAST_ALERT)) -ge $((COOLDOWN * 1000)) ]; then
      LAST_ALERT="$now"
      play_sound
      send_notification
    fi

    PENDING_TRIGGER=0
  fi
}

# ---------------------------
# Shell integration
# ---------------------------

add_shell() {
  SHELL_NAME=$(basename "${SHELL:-}")
  case "$SHELL_NAME" in
    zsh) RC="$HOME/.zshrc" ;;
    bash) RC="$HOME/.bashrc" ;;
    *) echo "Unsupported shell"; exit 1 ;;
  esac

  grep -q "promptbell integration" "$RC" 2>/dev/null && {
    echo "promptbell already added"
    exit 0
  }

  cat >>"$RC" <<'EOF'

# --- promptbell integration (start) ---
_promptbell_notice() {
  if [ -t 1 ]; then
    printf '%s\n' "ðŸ”” Notification sounds by promptbell. Disable or remove: promptbell --remove" >&2
  fi
}

gemini() {
  _promptbell_notice
  promptbell command gemini "$@"
}

codex() {
  _promptbell_notice
  promptbell command codex "$@"
}
# --- promptbell integration (end) ---

EOF

  echo "âœ… promptbell added to shell"
}

remove_shell() {
  for RC in "$HOME/.zshrc" "$HOME/.bashrc"; do
    [ -f "$RC" ] && sed -i.bak '/promptbell integration (start)/,/promptbell integration (end)/d' "$RC"
  done
  echo "ðŸ§¹ Shell integration removed"
}

# ---------------------------
# Notify mode commands
# ---------------------------

notify_list() {
  cat <<EOF
Notification modes:
  background  Notify only when terminal is not focused (default)
  always      Always notify
EOF
}

notify_use() {
  case "${1:-}" in
    background|always)
      echo "$1" >"$NOTIFY_MODE_FILE"
      echo "ðŸ”” Notification mode set to '$1'"
      ;;
    *)
      echo "Unknown notify mode"
      exit 1
      ;;
  esac
}

# ---------------------------
# CLI routing
# ---------------------------

case "${1:-}" in
  --add) add_shell; exit 0 ;;
  --remove) remove_shell; exit 0 ;;
  notify)
    case "${2:-}" in
      list) notify_list ;;
      use) notify_use "${3:-}" ;;
      *) echo "Usage: promptbell notify list|use <mode>" ;;
    esac
    exit 0
    ;;
esac

# ---------------------------
# Command wrapper (PTY)
# ---------------------------

[ "$#" -eq 0 ] && { echo "Usage: promptbell <command>"; exit 1; }

run_loop() {
  while IFS= read -r line; do
    printf '%s\n' "$line"
    LAST_OUTPUT_MS="$(now_ms)"

    if is_menu_line "$line"; then
      now="$(now_ms)"

      if [ $((now - LAST_MENU_LINE_MS)) -le "$MENU_MAX_GAP_MS" ]; then
        MENU_STREAK=$((MENU_STREAK + 1))
      else
        MENU_STREAK=1
      fi

      LAST_MENU_LINE_MS="$now"

      [ "$MENU_STREAK" -ge 2 ] && PENDING_TRIGGER=1
    else
      MENU_STREAK=0
    fi

    try_notify_if_idle
  done
}

if command -v script >/dev/null 2>&1; then
  script -q /dev/null "$@" 2>&1 | run_loop
else
  "$@" 2>&1 | run_loop
fi
