#!/usr/bin/env sh
set -eu

# ---------------------------
# Internal routing marker
# ---------------------------
# Shell integration calls:
#   promptbell command <real-command> [args...]
# This MUST run before any other argument handling.
if [ "${1:-}" = "command" ]; then
  shift
fi

APP_NAME="promptbell"

# ---------------------------
# Version handling
# ---------------------------

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
VERSION="unknown"

if [ -f "$SCRIPT_DIR/version.txt" ]; then
  VERSION="$(cat "$SCRIPT_DIR/version.txt" | tr -d '\n')"
fi

# ---------------------------
# State
# ---------------------------

STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/promptbell"
SOUND_FILE="$STATE_DIR/sound"

COOLDOWN=3
IDLE_THRESHOLD_MS=500

mkdir -p "$STATE_DIR"

# ---------------------------
# Sound handling
# ---------------------------

current_sound() {
  if [ -f "$SOUND_FILE" ]; then
    cat "$SOUND_FILE"
  else
    echo "default"
  fi
}

play_sound() {
  SOUND="$(current_sound)"

  case "$SOUND" in
    none) return ;;
    default)
      if command -v afplay >/dev/null 2>&1; then
        afplay /System/Library/Sounds/Glass.aiff &
      elif command -v paplay >/dev/null 2>&1; then
        paplay /usr/share/sounds/freedesktop/stereo/complete.oga &
      fi
      ;;
    glass) afplay /System/Library/Sounds/Glass.aiff & ;;
    ping)  afplay /System/Library/Sounds/Ping.aiff & ;;
    pop)   afplay /System/Library/Sounds/Pop.aiff & ;;
    bell)  paplay /usr/share/sounds/freedesktop/stereo/bell.oga & ;;
  esac
}

notify() {
  if command -v osascript >/dev/null 2>&1; then
    osascript -e 'display notification "User attention needed" with title "promptbell"' &
  elif command -v notify-send >/dev/null 2>&1; then
    notify-send "promptbell" "User attention needed" &
  fi
}

# ---------------------------
# Menu + idle detection
# ---------------------------

LAST_ALERT=0
LAST_OUTPUT_MS=0
PENDING_TRIGGER=0

MENU_STREAK=0
LAST_MENU_LINE_MS=0
MENU_MAX_GAP_MS=200

now_ms() {
  date +%s%3N 2>/dev/null || echo $(( $(date +%s) * 1000 ))
}

is_menu_line() {
  # Matches:
  #   1. Option
  #   2) Option
  #   [3] Option
  echo "$1" | grep -Eq '^\s*(\[[0-9]+\]|[0-9]+[.)])\s+'
}

alert_if_idle() {
  [ "$PENDING_TRIGGER" -eq 1 ] || return

  now="$(now_ms)"
  idle_ms=$(( now - LAST_OUTPUT_MS ))

  if [ "$idle_ms" -ge "$IDLE_THRESHOLD_MS" ]; then
    if [ $((now - LAST_ALERT)) -ge $((COOLDOWN * 1000)) ]; then
      LAST_ALERT="$now"
      play_sound
      notify
    fi
    PENDING_TRIGGER=0
  fi
}

# ---------------------------
# Sounds subcommand
# ---------------------------

sounds_list() {
  cat <<EOF
Available sounds:
  default  (system default)
  glass    (macOS)
  ping     (macOS)
  pop      (macOS)
  bell     (Linux)
  none     (disable sound)
EOF
}

sounds_use() {
  case "${1:-}" in
    default|glass|ping|pop|bell|none)
      echo "$1" >"$SOUND_FILE"
      echo "üîî promptbell sound set to '$1'"
      ;;
    *)
      echo "Unknown sound: ${1:-}"
      echo "Run: promptbell sounds list"
      exit 1
      ;;
  esac
}

# ---------------------------
# Shell integration
# ---------------------------

add_shell() {
  SHELL_NAME="$(basename "${SHELL:-}")"
  case "$SHELL_NAME" in
    zsh)  RC="$HOME/.zshrc" ;;
    bash) RC="$HOME/.bashrc" ;;
    *)
      echo "Unsupported shell: $SHELL_NAME"
      exit 1
      ;;
  esac

  if grep -q "promptbell integration" "$RC" 2>/dev/null; then
    echo "promptbell is already added"
    exit 0
  fi

  cat >>"$RC" <<EOF

# --- promptbell integration (start) ---
_promptbell_notice() {
  if [ -t 1 ]; then
    printf '%s\n' "üîî Notification sounds by promptbell v$VERSION. Disable or remove: promptbell --remove" >&2
  fi
}

gemini() {
  _promptbell_notice
  promptbell command gemini "\$@"
}

codex() {
  _promptbell_notice
  promptbell command codex "\$@"
}
# --- promptbell integration (end) ---

EOF

  echo "‚úÖ promptbell added to shell"
  echo "Restart your terminal or run: source $RC"
}

remove_shell() {
  for RC in "$HOME/.zshrc" "$HOME/.bashrc"; do
    [ -f "$RC" ] || continue
    sed -i.bak '/promptbell integration (start)/,/promptbell integration (end)/d' "$RC"
  done

  echo "üßπ Shell integration removed"
  echo ""
  echo "To completely uninstall promptbell:"
  echo "  promptbell uninstall"
}

# ---------------------------
# Uninstall
# ---------------------------

uninstall_promptbell() {
  BIN_PATH="$(command -v promptbell || true)"

  if [ -z "$BIN_PATH" ]; then
    echo "promptbell is not installed"
    exit 1
  fi

  echo "This will remove the promptbell binary:"
  echo "  $BIN_PATH"
  printf "Continue? [y/N]: "
  read -r answer

  case "$answer" in
    y|Y|yes|YES)
      rm -f "$BIN_PATH"
      echo "üóëÔ∏è  promptbell uninstalled"
      ;;
    *)
      echo "Aborted"
      ;;
  esac
}

# ---------------------------
# CLI routing
# ---------------------------

case "${1:-}" in
  --add)       add_shell; exit 0 ;;
  --remove)    remove_shell; exit 0 ;;
  uninstall)   uninstall_promptbell; exit 0 ;;
  sounds)
    case "${2:-}" in
      list) sounds_list ;;
      use)  sounds_use "${3:-}" ;;
      *)
        echo "Usage:"
        echo "  promptbell sounds list"
        echo "  promptbell sounds use <name>"
        exit 1
        ;;
    esac
    exit 0
    ;;
  --help)
    cat <<EOF
promptbell ‚Äî notification sounds for CLI-based AI coding assistants

Usage:
  promptbell <command> [args...]
  promptbell --add
  promptbell --remove
  promptbell uninstall
  promptbell sounds list
  promptbell sounds use <name>
  promptbell --help

Description:
  promptbell plays notification sounds for CLI-based AI coding
  assistants (like gemini and codex) when user attention is needed.

Install / Remove:
  --add        Add promptbell to your shell (automatic notifications)
  --remove     Remove shell integration (keeps binary)
  uninstall    Remove the promptbell binary from your system
EOF
    exit 0
    ;;
esac

# ---------------------------
# Command wrapper (PTY-aware)
# ---------------------------

if [ "$#" -eq 0 ]; then
  echo "Usage: promptbell <command> [args...]"
  exit 1
fi

run_loop() {
  while IFS= read -r line; do
    if [ "${ECHO_OUTPUT:-1}" -eq 1 ]; then
      printf '%s\n' "$line"
    fi
    LAST_OUTPUT_MS="$(now_ms)"

    if is_menu_line "$line"; then
      now="$(now_ms)"
      if [ $((now - LAST_MENU_LINE_MS)) -le "$MENU_MAX_GAP_MS" ]; then
        MENU_STREAK=$((MENU_STREAK + 1))
      else
        MENU_STREAK=1
      fi
      LAST_MENU_LINE_MS="$now"
      [ "$MENU_STREAK" -ge 2 ] && PENDING_TRIGGER=1
    else
      MENU_STREAK=0
    fi

    alert_if_idle
  done
}

run_with_parser() {
  if command -v mkfifo >/dev/null 2>&1; then
    PIPE_PATH="$STATE_DIR/stream.$$"
    if mkfifo "$PIPE_PATH" 2>/dev/null; then
      # Tee keeps interactive output flowing even when parsing waits on newlines.
      ECHO_OUTPUT=0 run_loop <"$PIPE_PATH" &
      PARSER_PID=$!
      if command -v script >/dev/null 2>&1; then
        # PTY mode ‚Äî preserves rich CLI UI
        script -q /dev/null "$@" 2>&1 | tee "$PIPE_PATH"
      else
        # Fallback pipe mode
        "$@" 2>&1 | tee "$PIPE_PATH"
      fi
      CMD_STATUS=$?
      wait "$PARSER_PID" 2>/dev/null || true
      rm -f "$PIPE_PATH"
      return "$CMD_STATUS"
    fi
  fi

  # Fallback when mkfifo is unavailable.
  if command -v script >/dev/null 2>&1; then
    # PTY mode ‚Äî preserves rich CLI UI
    script -q /dev/null "$@" 2>&1 | run_loop
  else
    # Fallback pipe mode
    "$@" 2>&1 | run_loop
  fi
}

run_with_parser "$@"
